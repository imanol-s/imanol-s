---
// Lightweight Dallas crime correlation animation
// Plays once (6 seconds) then stops
const seed = 42; // Default seed, can be customized via props
const { seed: customSeed = 42 } = Astro.props;
---

<div class="dallas-animation-container">
    <canvas id="dallas-canvas"></canvas>
</div>

<script define:vars={{ seed: customSeed }}>
    // Import p5.js if not already loaded
    if (typeof p5 === 'undefined') {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js';
        script.onload = () => initDallasAnimation();
        document.head.appendChild(script);
    } else {
        initDallasAnimation();
    }

    function initDallasAnimation() {
        const container = document.querySelector('.dallas-animation-container');
        if (!container || container.querySelector('canvas').getContext('2d').canvas.width > 0) return;

        new p5((p) => {
            let cells = [];
            let animProgress = 0;
            let animationComplete = false;
            const ANIMATION_DURATION = 360; // 6 seconds at 60fps
            const RELAXATION_DURATION = 280; // Stop relaxation at ~4.6 seconds

            const params = {
                seed: seed,
                pointCount: 80,
                contrast: 0.8,
                edgeWeight: 1.2,
                noiseAmount: 0.008
            };

            p.setup = function() {
                const canvas = p.createCanvas(800, 800);
                canvas.parent(container);
                
                p.randomSeed(params.seed);
                p.noiseSeed(params.seed);

                // Generate neighborhood data points
                for (let i = 0; i < params.pointCount; i++) {
                    let x = p.random(p.width * 0.1, p.width * 0.9);
                    let y = p.random(p.height * 0.1, p.height * 0.9);
                    let crimeRate = p.random(0, 1);
                    let propertyValue = 1 - crimeRate + p.random(-0.3, 0.3);
                    propertyValue = p.constrain(propertyValue, 0, 1);
                    
                    cells.push({
                        x: x,
                        y: y,
                        crimeRate: crimeRate,
                        propertyValue: propertyValue,
                        radius: p.random(30, 60)
                    });
                }

                p.background(250, 249, 245);
            };

            p.draw = function() {
                if (animationComplete) {
                    p.noLoop();
                    return;
                }

                p.background(250, 249, 245);
                
                animProgress++;
                let progress = p.min(animProgress / ANIMATION_DURATION, 1);
                
                // Lloyd's relaxation (only during first part of animation)
                if (animProgress < RELAXATION_DURATION) {
                    for (let cell of cells) {
                        let forceX = 0;
                        let forceY = 0;
                        
                        for (let other of cells) {
                            if (cell !== other) {
                                let dx = cell.x - other.x;
                                let dy = cell.y - other.y;
                                let dist = p.sqrt(dx * dx + dy * dy);
                                if (dist < 80 && dist > 0) {
                                    let force = (80 - dist) / 80;
                                    forceX += (dx / dist) * force;
                                    forceY += (dy / dist) * force;
                                }
                            }
                        }
                        
                        cell.x += forceX * 0.5;
                        cell.y += forceY * 0.5;
                        cell.x = p.constrain(cell.x, 50, p.width - 50);
                        cell.y = p.constrain(cell.y, 50, p.height - 50);
                    }
                }

                // Draw cells
                for (let cell of cells) {
                    drawCell(cell, progress);
                }

                // Draw boundaries
                p.stroke(40, 40, 45, 150);
                p.strokeWeight(0.5);
                p.noFill();
                for (let i = 0; i < cells.length; i++) {
                    for (let j = i + 1; j < cells.length; j++) {
                        let c1 = cells[i];
                        let c2 = cells[j];
                        let dist = p.sqrt((c1.x - c2.x) ** 2 + (c1.y - c2.y) ** 2);
                        
                        if (dist < 120) {
                            let correlation = p.abs(c1.crimeRate - c2.crimeRate);
                            let weight = p.map(correlation, 0, 1, 0.3, params.edgeWeight * 3);
                            let alpha = p.map(dist, 0, 120, 150, 0);
                            
                            p.strokeWeight(weight);
                            p.stroke(40, 40, 45, alpha * progress);
                            
                            // Organic distortion
                            let midX = (c1.x + c2.x) / 2;
                            let midY = (c1.y + c2.y) / 2;
                            let offsetX = p.noise(midX * params.noiseAmount, midY * params.noiseAmount) * 20 - 10;
                            let offsetY = p.noise(midX * params.noiseAmount + 100, midY * params.noiseAmount) * 20 - 10;
                            
                            p.beginShape();
                            p.vertex(c1.x, c1.y);
                            p.quadraticVertex(midX + offsetX, midY + offsetY, c2.x, c2.y);
                            p.endShape();
                        }
                    }
                }

                // Stop when complete
                if (animProgress >= ANIMATION_DURATION) {
                    animationComplete = true;
                }
            };

            function drawCell(cell, progress) {
                // Color encoding
                let hue = p.map(cell.crimeRate, 0, 1, 220, 0);
                let sat = p.map(cell.propertyValue, 0, 1, 30, 80) * params.contrast;
                let bright = p.map(cell.propertyValue, 0, 1, 60, 85);
                
                p.colorMode(p.HSB, 360, 100, 100);
                p.fill(hue, sat, bright, progress * 100);
                p.noStroke();
                
                // Draw cell with noise distortion
                p.beginShape();
                let segments = 32;
                for (let i = 0; i < segments; i++) {
                    let angle = (i / segments) * p.TWO_PI;
                    let r = cell.radius;
                    let noiseVal = p.noise(
                        cell.x * 0.01 + p.cos(angle) * 0.5,
                        cell.y * 0.01 + p.sin(angle) * 0.5
                    );
                    r += p.map(noiseVal, 0, 1, -10, 10) * params.noiseAmount * 500;
                    
                    let x = cell.x + p.cos(angle) * r;
                    let y = cell.y + p.sin(angle) * r;
                    p.vertex(x, y);
                }
                p.endShape(p.CLOSE);
                
                p.colorMode(p.RGB, 255);
            }
        }, container);
    }
</script>

<style>
    .dallas-animation-container {
        width: 100%;
        height: auto;
        border-radius: 1rem;
        overflow: hidden;
        background: #faf9f5;
    }
    
    .dallas-animation-container canvas {
        width: 100% !important;
        height: auto !important;
        display: block;
    }
</style>

---
// Lightweight robotics pathfinding animation
// Plays once (6 seconds) then stops
const seed = 42; // Default seed, can be customized via props
const { seed: customSeed = 42 } = Astro.props;
---

<div class="robotics-animation-container">
    <canvas id="robotics-canvas"></canvas>
</div>

<script define:vars={{ seed: customSeed }}>
    // Import p5.js if not already loaded
    if (typeof p5 === 'undefined') {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js';
        script.onload = () => initRoboticsAnimation();
        document.head.appendChild(script);
    } else {
        initRoboticsAnimation();
    }

    function initRoboticsAnimation() {
        const container = document.querySelector('.robotics-animation-container');
        if (!container || container.dataset.initialized) return;
        container.dataset.initialized = 'true';

        new p5((p) => {
            let particles = [];
            let terrainField = [];
            let cols, rows;
            let scl = 8;
            let animProgress = 0;
            let animationComplete = false;
            const ANIMATION_DURATION = 360; // 6 seconds at 60fps

            const params = {
                seed: seed,
                explorerCount: 800,
                terrainScale: 0.006,
                convergence: 1.5,
                trailDecay: 0.96
            };

            p.setup = function() {
                const canvas = p.createCanvas(800, 800);
                canvas.parent(container);
                
                p.randomSeed(params.seed);
                p.noiseSeed(params.seed);

                // Initialize particles
                for (let i = 0; i < params.explorerCount; i++) {
                    particles.push(new Explorer());
                }

                // Generate terrain field
                cols = p.floor(p.width / scl);
                rows = p.floor(p.height / scl);
                
                for (let y = 0; y < rows; y++) {
                    let row = [];
                    for (let x = 0; x < cols; x++) {
                        let noiseVal = p.noise(x * params.terrainScale, y * params.terrainScale);
                        let angle = p.map(noiseVal, 0, 1, -p.TWO_PI, p.TWO_PI);
                        row.push(p.createVector(p.cos(angle), p.sin(angle)));
                    }
                    terrainField.push(row);
                }

                p.background(18, 18, 20);
            };

            p.draw = function() {
                if (animationComplete) {
                    p.noLoop();
                    return;
                }

                // Fade effect
                p.fill(18, 18, 20, (1 - params.trailDecay) * 255);
                p.rect(0, 0, p.width, p.height);
                
                animProgress++;
                let progress = p.min(animProgress / ANIMATION_DURATION, 1);

                // Update particles
                for (let particle of particles) {
                    particle.follow(terrainField);
                    particle.update();
                    particle.show(progress);
                    particle.edges();
                }

                // Stop when complete
                if (animProgress >= ANIMATION_DURATION) {
                    animationComplete = true;
                }
            };

            class Explorer {
                constructor() {
                    this.pos = p.createVector(p.random(p.width), p.random(p.height));
                    this.vel = p.createVector(0, 0);
                    this.acc = p.createVector(0, 0);
                    this.maxSpeed = params.convergence * 2;
                    this.age = 0;
                    this.maxAge = p.random(200, 400);
                }

                follow(field) {
                    let x = p.floor(this.pos.x / scl);
                    let y = p.floor(this.pos.y / scl);
                    x = p.constrain(x, 0, cols - 1);
                    y = p.constrain(y, 0, rows - 1);
                    let force = field[y][x].copy();
                    force.mult(0.5);
                    this.applyForce(force);
                }

                applyForce(force) {
                    this.acc.add(force);
                }

                update() {
                    this.vel.add(this.acc);
                    this.vel.limit(this.maxSpeed);
                    this.pos.add(this.vel);
                    this.acc.mult(0);
                    this.age++;

                    if (this.age > this.maxAge) {
                        this.pos = p.createVector(p.random(p.width), p.random(p.height));
                        this.vel = p.createVector(0, 0);
                        this.age = 0;
                    }
                }

                show(progress) {
                    let speed = this.vel.mag();
                    let normalizedSpeed = p.map(speed, 0, this.maxSpeed, 0, 1);
                    
                    let r, g, b;
                    if (normalizedSpeed < 0.5) {
                        r = p.lerp(60, 120, normalizedSpeed * 2);
                        g = p.lerp(120, 200, normalizedSpeed * 2);
                        b = p.lerp(200, 100, normalizedSpeed * 2);
                    } else {
                        r = p.lerp(120, 255, (normalizedSpeed - 0.5) * 2);
                        g = p.lerp(200, 180, (normalizedSpeed - 0.5) * 2);
                        b = p.lerp(100, 50, (normalizedSpeed - 0.5) * 2);
                    }

                    let ageOpacity = p.map(this.age, 0, this.maxAge, 180, 20);
                    
                    p.stroke(r, g, b, ageOpacity * progress);
                    p.strokeWeight(1 + normalizedSpeed);
                    p.point(this.pos.x, this.pos.y);
                }

                edges() {
                    if (this.pos.x > p.width) this.pos.x = 0;
                    if (this.pos.x < 0) this.pos.x = p.width;
                    if (this.pos.y > p.height) this.pos.y = 0;
                    if (this.pos.y < 0) this.pos.y = p.height;
                }
            }
        }, container);
    }
</script>

<style>
    .robotics-animation-container {
        width: 100%;
        height: auto;
        border-radius: 1rem;
        overflow: hidden;
        background: #121214;
    }
    
    .robotics-animation-container canvas {
        width: 100% !important;
        height: auto !important;
        display: block;
    }
</style>
